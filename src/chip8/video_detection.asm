
	SECTION	CODE

	PUBLIC _videoChipProbe

	INCLUDE "v9958.inc"

; CODE COPIED FROM HTTP://MAP.GRAUW.NL/SOURCES/VDP_DETECTION.PHP

; DETECT VDP VERSION
;
; L <- 0: TMS9918A, 1: V9938, 2: V9958, X: VDP ID
; F <- Z: TMS9918A, NZ: OTHER
;
_videoChipProbe:
	CALL	VDP_PROBE
	JR	NZ, VDP_NOT_FOUND

	CALL	VDP_ISTMS9918A		; USE A DIFFERENT WAY TO DETECT TMS9918A
	RET	Z
	LD	A, 1			; SELECT S#1
	DI
	OUT	(VDP_ADDR),A
	LD	A, $80 | 15
	OUT	(VDP_ADDR),A
	IN	A, (VDP_ADDR)		; READ S#1
	AND	00111110B		; GET VDP ID
	RRCA
	EX	AF, AF'
	XOR	A			; SELECT S#0 AS REQUIRED BY BIOS
	OUT	(VDP_ADDR), A
	LD	A, $80 | 15
	EI
	OUT	(VDP_ADDR), A
	EX	AF, AF'
	LD	L, A
	RET	NZ			; RETURN VDP ID FOR V9958 OR HIGHER
	INC	L			; RETURN 1 FOR V9938
	RET

VDP_NOT_FOUND:
	LD	L, 255
	RET

VDP_PROBE:
	DI
	; READ FIRST BYTE - SO WE CAN RESTORE IT.
	LD	HL, 0
	CALL	TMS_RD
	IN	A, (VDP_DATA)		; READ FIRST BYTE
	LD	D, A
	CALL	DELAY
	IN	A, (VDP_DATA)		; READ SECOND BYTE
	CALL	DELAY
	LD	E, A

	; SET WRITE ADDRESS TO $0
	LD	HL, 0
	CALL	TMS_WR
	; WRITE TEST PATTERN TO FIRST TWO BYTES
	LD	A, $A5			; FIRST BYTE
	OUT	(VDP_DATA), A		; OUTPUT
	CALL	DELAY			; DELAY
	CPL				; COMPLEMENT ACCUM
	OUT	(VDP_DATA), A		; SECOND BYTE
	CALL	DELAY			; DELAY

	; SET READ ADDRESS TO $0
	LD	HL, 0
	CALL	TMS_RD
	; VERIFY TEST PATTERN
	LD	C, $A5			; VALUE TO EXPECT
	IN	A, (VDP_DATA)		; READ FIRST BYTE
	CALL	DELAY			; DELAY
	CP	C			; COMPARE
	RET	NZ			; RETURN ON MISCOMPARE
	IN	A, (VDP_DATA)		; READ SECOND BYTE
	CALL	DELAY			; DELAY
	CPL				; COMPLEMENT IT
	CP	C			; COMPARE
	RET	NZ			; RETURN ON MISCOMPARE

	LD	HL, 0
	CALL	TMS_WR
	; RESTORE DATA
	LD	A, D			; FIRST BYTE
	OUT	(VDP_DATA), A		; OUTPUT
	CALL	DELAY			; DELAY
	LD	A, E
	OUT	(VDP_DATA), A		; SECOND BYTE

	EI
	XOR	A
	RET				; RETURN Z TO INDICATE FOUND HARDWARE.


TMS_WR:
	PUSH	HL
	SET	6, H			; SET WRITE BIT
	CALL	TMS_RD
	POP	HL
	RET
;
TMS_RD:
	LD	A, L
	OUT	(VDP_ADDR), A
	CALL	DELAY
	LD	A, H
	OUT	(VDP_ADDR), A
	CALL	DELAY
	RET

DELAY:
	EX (SP), HL
	EX (SP), HL
	EX (SP), HL
	EX (SP), HL
	RET
;
; TEST IF THE VDP IS A TMS9918A.
;
; THE VDP ID NUMBER WAS ONLY INTRODUCED IN THE V9938, SO WE HAVE TO USE A
; DIFFERENT METHOD TO DETECT THE TMS9918A. WE WAIT FOR THE VERTICAL BLANKING
; INTERRUPT FLAG, AND THEN QUICKLY READ STATUS REGISTER 2 AND EXPECT BIT 6
; (VR, VERTICAL RETRACE FLAG) TO BE SET AS WELL. THE TMS9918A HAS ONLY ONE
; STATUS REGISTER, SO BIT 6 (5S, 5TH SPRITE FLAG) WILL RETURN 0 IN STEAD.
;
; F <- Z: TMS9918A, NZ: V99X8
;
VDP_ISTMS9918A:
	IN	A, (VDP_ADDR)		; READ S#0, MAKE SURE INTERRUPT FLAG IS RESET
	DI

VDP_ISTMS9918A_WAIT:
	IN	A, (VDP_ADDR)		; READ S#0
	AND	A			; WAIT UNTIL INTERRUPT FLAG IS SET
	JP	P, VDP_ISTMS9918A_WAIT

	LD	A, 2			; SELECT S#2 ON V9938
	OUT	(VDP_ADDR), A
	CALL	DELAY
	LD	A, $80 | 15		; (THIS MIRRORS TO R#7 ON TMS9918 VDPS)
	OUT	(VDP_ADDR), A
	CALL	DELAY
	IN	A, (VDP_ADDR)		; READ S#2 / S#0

	EX	AF,AF'

	XOR	A			; RESELECT DEFAULT S#0
	OUT	(VDP_ADDR),A
	CALL	DELAY
	LD	A, $80 | 15
	OUT	(VDP_ADDR),A

	EI
	EX	AF, AF'
	AND	01000000B        ; CHECK IF BIT 6 WAS 0 (S#0 5S) OR 1 (S#2 VR)
	RET

	SECTION	IGNORE
